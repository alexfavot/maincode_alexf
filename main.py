{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 52,
   "id": "3635c351-ee0b-419b-90da-b455594ca0ea",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import csv\n",
    "import geopandas as gpd\n",
    "import fiona\n",
    "from shapely.geometry import Polygon, LineString, Point\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from sklearn.cluster import DBSCAN\n",
    "from sklearn.datasets import make_blobs\n",
    "from shapely.ops import transform"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "id": "ea0bb161-cb07-405f-b91f-37a12a03bfbc",
   "metadata": {},
   "outputs": [],
   "source": [
    "def extraction_of_data(trajectorycsv) :\n",
    "#This fonction converts the information that are in a csv into a dataframe. The input : trajectorycsv is the path to the csv of a video : the trajectories from DataFromSkyViewer. There are 2 outputs : \n",
    "#len_video : the length of the video in frames\n",
    "#output_df : a dataframe which gathers each entity at each frames with information like : TrackID, Time, X, Y, Speed\n",
    "\n",
    "    output = []\n",
    "    with open(trajectorycsv) as f:\n",
    "        reader = csv.reader(f, delimiter=',')\n",
    "        if 'Trajectory(x' in list(reader)[0][10]:\n",
    "            indx = 10\n",
    "        else:\n",
    "            indx = 8\n",
    "            \n",
    "    with open(trajectorycsv) as f:\n",
    "        reader = csv.reader(f, delimiter=',')\n",
    "        if indx == 10:\n",
    "            for row in reader:\n",
    "                part1 = row[:indx]\n",
    "                TrackID,Type,Colour,LicencePlate,EntryGate,EntryTime,ExitGate,ExitTime,TraveledDist,AvgSpeed = part1\n",
    "                part2 = row[indx:]\n",
    "                big_list = part2\n",
    "                chunk_size = 6\n",
    "                while big_list:\n",
    "                    chunk, big_list = big_list[:chunk_size], big_list[chunk_size:]\n",
    "                    if len(chunk) == chunk_size:\n",
    "                        X,Y,Speed,TanAcc,LatAcc,Time = chunk\n",
    "                        output.append((Time,TrackID,Type,X,Y,Speed))\n",
    "                        \n",
    "        if indx == 8:\n",
    "            for row in reader:\n",
    "                part1 = row[:indx]\n",
    "                TrackID,Type,EntryGate,EntryTime,ExitGate,ExitTime,TraveledDist,AvgSpeed = part1\n",
    "                part2 = row[indx:]\n",
    "                big_list = part2\n",
    "                chunk_size = 6\n",
    "                while big_list:\n",
    "                    chunk, big_list = big_list[:chunk_size], big_list[chunk_size:]\n",
    "                    if len(chunk) == chunk_size:\n",
    "                        X,Y,Speed,TanAcc,LatAcc,Time = chunk\n",
    "                        output.append((Time,TrackID,Type,X,Y,Speed))\n",
    "    col_names = [\"Time\",\"TrackID\",\"Type\",\"X\",\"Y\",\"Speed\"]\n",
    "    output_df = pd.DataFrame.from_records(output,columns=col_names)\n",
    "    output_df.drop([0],inplace=True)\n",
    "    output_df.to_csv('DFS_reformat.csv',index=False)\n",
    "    output_df = output_df[output_df['Time'] != ' ']\n",
    "    #There are sometimes blank space : ' ' in the Time column that creates error. We delete those to be sure to have no problems.\n",
    "    output_df['Time'] = output_df['Time'].astype(float)\n",
    "    len_video = output_df.Time.max()/0.03333\n",
    "    #the video is in 30fps so we convert seconds into frames by dividing by (1/30)\n",
    "    len_video = int(len_video)\n",
    "    return output_df,len_video                    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "id": "2af4a5bf-7530-44bc-abc4-ac0aa2284ae9",
   "metadata": {},
   "outputs": [],
   "source": [
    "def creation_of_gdf2(output_df) :\n",
    "    #This fonction filters output_df. It keeps only the information concerning pedestrians, because this is what we care about here.\n",
    "    #The output gdf2 is a geodataframe with every information of pedestrians in the current video.\n",
    "    output_df2 = output_df.loc[output_df['Type'] == ' Pedestrian'].copy()\n",
    "    output_df2['spatially']=0\n",
    "    output_df2['temporally']=0\n",
    "    output_df2[\"geometry\"] = output_df2.apply(lambda row: Point(row[\"Y\"], row[\"X\"]), axis=1)\n",
    "    # The coordinates are (Y,X) here, it comes from the initial csv.\n",
    "    gdf2 = gpd.GeoDataFrame(output_df2, geometry=\"geometry\")\n",
    "    return gdf2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "id": "64dfe61c-773c-4f76-8c71-582eade205cc",
   "metadata": {},
   "outputs": [],
   "source": [
    "def creation_of_gdf_trajectory(gdf2) :\n",
    "    #This fonction creates a geodataframe with all the trajectories : 1 line is 1 trajectory and the length of the gdf is equal to the number of pedestrian\n",
    "    #each trajectory has information about the id of the pedestrian, the length and the linestring : Linestring(Point1,Point2,....,Pointn)\n",
    "    #The input is gdf2 : a geodataframe which has only information about pedestrian, here 1 line is 1 position\n",
    "    list_trajectory=[]\n",
    "    list_length=[]\n",
    "    list_points =[]\n",
    "    list_id = []\n",
    "    for i, row in gdf2.groupby('TrackID'):\n",
    "        points = [Point(x, y) for x, y in zip(row['Y'], row['X'])]\n",
    "        trajectory = LineString(points)\n",
    "        length=trajectory.length\n",
    "        list_trajectory.append(trajectory)\n",
    "        list_length.append(length)\n",
    "        list_points.append(points)\n",
    "        list_id.append(i)\n",
    "    \n",
    "    df_trajectory = pd.DataFrame({'TrackID':list_id, 'length':list_length,'points':list_points})\n",
    "    gdf_trajectory = gpd.GeoDataFrame(df_trajectory, geometry=list_trajectory)\n",
    "    gdf_trajectory = gdf_trajectory.sort_values(['TrackID'], ascending=True)\n",
    "    return gdf_trajectory"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "id": "40dc0efb-fe5d-4040-8491-03844d5ee5cf",
   "metadata": {},
   "outputs": [],
   "source": [
    "#geomdata = gpd.read_file(intersectionshapefile)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "id": "bb4039f6-90d8-49a2-ad10-22347be5a4d2",
   "metadata": {},
   "outputs": [],
   "source": [
    "def check_location(gdf2,geomdata) :\n",
    "    #This fonction checks every position and attributes to it a location on the map\n",
    "    #The input are gdf2 (gdf of every pedestrian) and geomdata the shapefile of the intersection, each part of the intersection is a polygon. We check for each point in gdf2 whether the point is in a\n",
    "    #polygon or not. If the point is outside every polygon, it is in \"footpath\"\n",
    "    #The ouput is gdf2 with two new columns : \"loc\", which is the polygon where the point is inside of and 'loc_type' which is the type of the polygon : \"road\" ,\"cw\" or \"footpath\".\n",
    "    gdf2['loc'] = 'footpath'\n",
    "    gdf2['loc_type'] = 'footpath'\n",
    "    for index, polygon in geomdata.iterrows():\n",
    "        mask = gdf2.within(polygon['geometry'])\n",
    "        gdf2.loc[mask, 'loc'] = polygon['name']\n",
    "        gdf2.loc[mask,'loc_type']= polygon['type']\n",
    "    return gdf2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "id": "baa3d332-6676-42b4-b00f-cf2c158323de",
   "metadata": {},
   "outputs": [],
   "source": [
    "def light_gate_column(geomdata) :\n",
    "    #This fonction delete the light_gate column in the gdf geomdata. The light gate column indicates for each polygons which gates they are related to in DFS it is something like : \"'Gate 1','Gate 2'\"\n",
    "    #The goal here is to have list_list_gate which is a list of each gates related to a polygon : [['Gate 1','Gate 2'],['Gate 4'],['Gate 3','Gate 4']]\n",
    "    #If a polygon isn't related to a specific gate it has 0 in this column and ['0'] in the list_list_gate\n",
    "    #The ouput is geomdata with a new column list_gate = list_list_gate\n",
    "    list_list_gate = []\n",
    "    for listgate in geomdata['light_gate'].tolist() :\n",
    "        lst = listgate.split(\"','\")\n",
    "        list_gate = [element.strip(\"'\") for element in lst]\n",
    "        list_list_gate.append(list_gate)\n",
    "        #list_list_gate is like : [[list_gate1],[list_gate2],[list_gate3]...]\n",
    "    geomdata['list_gate'] = list_list_gate\n",
    "    geomdata.drop('light_gate', axis=1, inplace=True)\n",
    "    return geomdata,list_list_gate"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "id": "80712b8e-3840-413c-bdf4-ad6fe3eafe5d",
   "metadata": {},
   "outputs": [],
   "source": [
    "def importation_gate_event(gateeventcsv) :\n",
    "    #We want here to create a df : gate_df\n",
    "    #It is composed of every gate event (cars that cross a gate in DFS) on the gates that are concerned here.\n",
    "    #We filter the gate event to just have the gates that we care for\n",
    "    #The input is gateeventcsv, the path to the gate event csv from DFS\n",
    "    #The outputs are gate_df : a filtered gate event and list_list_gate (no changes on it)\n",
    "    Event_df = pd.read_csv(gateeventcsv)\n",
    "    Event_df = Event_df.loc[Event_df[' Type'] != ' Motorcycle'].copy()\n",
    "    Event_df = Event_df.loc[Event_df[' Type'] != ' Pedestrian'].copy()\n",
    "    Event_df = Event_df.loc[Event_df[' Type'] != ' Bicycle'].copy()\n",
    "    #We only want cars here (Bicyle are sometimes on the footpath and the road, Motorcycle are often stopped after a gate)\n",
    "    Event_df['pass'] = 1\n",
    "    \n",
    "    gates_list = []\n",
    "    for listgate in list_list_gate :\n",
    "        if listgate != ['0'] :\n",
    "            for i in range(len(listgate)) :\n",
    "                if listgate[i] not in gates_list :\n",
    "                    gates_list.append(listgate[i])\n",
    "                \n",
    "    gate_df = Event_df[Event_df.Gate.isin(gates_list)]\n",
    "    return gate_df, list_list_gate"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "id": "ebf2b552-1a67-46c3-94d3-b5ae447c7e3e",
   "metadata": {},
   "outputs": [],
   "source": [
    "def list_01_gates(list_list_gate,gate_df,len_video):\n",
    "    #This function creates a list : list_gate_01\n",
    "    #This list is a list of lists : each list has the same length as the video and is composed of 0 and 1. Each list is related to a list_gate and when a vehicle crosses the gate we put a 1 in the list.\n",
    "    #If nothing is passing through the gate we put a 0.\n",
    "    #When there are several gates in list_gate we add the information of crossing in the same list\n",
    "    #The inputs are list_list_gate, gate_df to have the information on crossing, len_video to fix the length of each list\n",
    "    #the outut is list_gate_01\n",
    "    list_gate_01 = []\n",
    "    \n",
    "    for lst in list_list_gate :\n",
    "        if lst == ['0'] :\n",
    "            listtoappend = ['0']\n",
    "        else :\n",
    "            listgate01 = [0] * len_video\n",
    "            for gate in lst :\n",
    "                data = gate_df[gate_df.Gate == gate ][[' Image ID', 'pass']]\n",
    "                list_x_1 = data[' Image ID'].tolist()\n",
    "                for i in range(len_video) :\n",
    "                    for j in range(len(list_x_1)) :\n",
    "                        if list_x_1[j] == i :\n",
    "                            listgate01[i] = 1\n",
    "            listgate01.pop(0)\n",
    "            listgate01.pop(1)\n",
    "            listgate01.pop(-1)\n",
    "            listgate01.pop(-2)\n",
    "            listtoappend = [0,0] + listgate01 + [0,0]\n",
    "        list_gate_01.append(listtoappend)\n",
    "    return list_gate_01"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "id": "48a6512b-2fa6-42f1-bca2-c515fce6b2ea",
   "metadata": {},
   "outputs": [],
   "source": [
    "def len_colour(lst, element):\n",
    "    #This fonction give the length of the successive elements : we use it to know how long are the phases\n",
    "    #It takes two inputs : the list we are looking in and element the element we are looking for\n",
    "    #The output is consecutive_occurences a list of each length of successive elements\n",
    "    counter = 0\n",
    "    consecutive_occurrences = []\n",
    "\n",
    "    for item in lst:\n",
    "        if item == element:\n",
    "            counter += 1\n",
    "        else:\n",
    "            if counter > 0:\n",
    "                consecutive_occurrences.append(counter)\n",
    "            counter = 0\n",
    "\n",
    "    if counter > 0:\n",
    "        consecutive_occurrences.append(counter)\n",
    "\n",
    "    return consecutive_occurrences"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "id": "9e362215-63d7-41a7-a9f0-bfc28439d9e4",
   "metadata": {},
   "outputs": [],
   "source": [
    "def smooth_data_1(list_gate_01):\n",
    "    #smooth_data_1 if function that smooth the previous data\n",
    "    #The input is list_gate_01. For each list in list_gate_01, this code check if there are 2 small signals next to each other. If this is the case, it merges the two small signal into a bigger one.\n",
    "    #The output is list_gate_01 with merged signal : the lengths of the successive 1 are bigger\n",
    "    cleanlist01 = []\n",
    "    for index in range(len(list_gate_01)) :\n",
    "        lst = list_gate_01[index]\n",
    "        if lst == ['0'] :\n",
    "            cleanlist01 = ['0']\n",
    "        else :\n",
    "            for a in range(20) :\n",
    "                list_index_var = []\n",
    "                listlengreen = []\n",
    "                listlenred = []\n",
    "                n  = 0\n",
    "                m = 3\n",
    "                for i in range(len(lst)-1) :\n",
    "                    if lst[i] != lst[i+1] :\n",
    "                        list_index_var.append(i+1)\n",
    "                listlengreen = len_colour(lst,1)\n",
    "                avglengreen = sum(listlengreen) / len(listlengreen)\n",
    "\n",
    "                for i in range(len(listlengreen)-1) :\n",
    "                    if listlengreen[i] < 600 :\n",
    "                        if listlengreen[i+1] < 600 :\n",
    "                            index1 = list_index_var[n]\n",
    "                            index2 =list_index_var[m]\n",
    "                            if list_index_var[m-1]-list_index_var[n+1] < 1000:\n",
    "                                new_data = [1] * (index2-index1)\n",
    "                                for k in range(index1,index2 + 1):\n",
    "                                    lst[k] = new_data[k - index1-1]\n",
    "\n",
    "                    n+=2\n",
    "                    m+=2\n",
    "            cleanlist01 = lst\n",
    "            list_gate_01[index] = cleanlist01\n",
    "        \n",
    "            listlengreen = len_colour(lst,1)\n",
    "            listlenred = len_colour(lst,0)\n",
    "    return list_gate_01"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "id": "0603b718-6c4b-4b25-8efe-b3301c465b6f",
   "metadata": {},
   "outputs": [],
   "source": [
    "def smooth_data_2(list_gate_01):\n",
    "    #smooth_data_2 is the 2nd smoothing function. The input is list_gate_01.\n",
    "    #This function works with the average length of green phases. If a signal is way smaller than the average, we extend it to have a signal that has the same length as the average of the length of green signals\n",
    "    #The output is list_gate_01, still a list of lists with 0 and 1.\n",
    "    cleanlist01 = []\n",
    "    for index in range(len(list_gate_01)) :\n",
    "        lst = list_gate_01[index]\n",
    "        if lst == ['0'] :\n",
    "            cleanlist01 = ['0']\n",
    "        else :\n",
    "            listlengreen = len_colour(lst,1)\n",
    "            listlenred = len_colour(lst,0)\n",
    "            avglengreen = sum(listlengreen) / len(listlengreen)\n",
    "            avglenred = sum(listlenred) / len(listlenred)\n",
    "            list_index_var = []\n",
    "            for i in range(len(lst)-1) :\n",
    "                if lst[i] != lst[i+1] :\n",
    "                    list_index_var.append(i+1)\n",
    "            n=0\n",
    "            for i in range(len(listlengreen)) :\n",
    "                #let's check every length of green phase\n",
    "                if listlengreen[i] < avglengreen-200 :\n",
    "                    #the signal is way smaller than the average, we have to make it bigger\n",
    "                    #there are 3 possible situations : \n",
    "                    #1) we have to extend it on the right\n",
    "                    if listlenred[i] <= avglenred and listlenred[i+1] >= avglenred :\n",
    "                        redtoreplace = int(listlenred[i+1] - avglenred)\n",
    "                        index1 = list_index_var[min(n+1,len(list_index_var)-1)]\n",
    "                        index2 = index1 + redtoreplace\n",
    "                        if index2 != index1 :\n",
    "                            new_data = [1] * (index2-index1)\n",
    "                            for k in range(index1,index2+1):\n",
    "                                lst[k] = new_data[k - index1-1]\n",
    "                    if listlenred[i] >= avglenred and listlenred[i+1] <= avglenred :\n",
    "                        #2) we have to extend it on the left\n",
    "                        redtoreplace = int(listlenred[i] - avglenred)\n",
    "                        index2 = list_index_var[min(n,len(list_index_var)-1)]\n",
    "                        index1 = index2 - redtoreplace\n",
    "                        if index2 != index1 : \n",
    "                            new_data = [1] * (index2-index1)\n",
    "                            for k in range(index1,index2+1):\n",
    "                                lst[k] = new_data[k - index1-1]\n",
    "                    if listlenred[i] >= avglenred and listlenred[i+1] >= avglenred :\n",
    "                        #3) we have to extend it on both side\n",
    "                        redtoreplaceleft = int(listlenred[i] - avglenred)\n",
    "                        redtoreplaceright = int(listlenred[i+1] - avglenred)\n",
    "                        greentoreplace = int(avglengreen - listlengreen[i])\n",
    "                        index1r = list_index_var[min(n+1,len(list_index_var)-1)]\n",
    "                        index2r = index1r + int(greentoreplace/2)\n",
    "                        index2l = list_index_var[min(n,len(list_index_var)-1)]\n",
    "                        index1l = index2l - int(greentoreplace/2)\n",
    "                        if greentoreplace/2 > redtoreplaceleft :\n",
    "                            index1l = list_index_var[min(n,len(list_index_var)-1)] - redtoreplaceleft\n",
    "\n",
    "                        if greentoreplace/2 > redtoreplaceright :\n",
    "                            index2r = list_index_var[min(n,len(list_index_var)-1)] + redtoreplaceright\n",
    "                        if index1r != index2r :\n",
    "                            new_data = [1] * (index2r-index1r)\n",
    "                            for k in range(index1r,index2r+1):\n",
    "                                lst[k] = new_data[k - index1r-1]\n",
    "                        if index1l != index2l : \n",
    "                            new_data = [1] * (index2l-index1l)\n",
    "                            for k in range(index1l,index2l+1):\n",
    "                                lst[k] = new_data[k - index1l-1]\n",
    "                n+=2\n",
    "        cleanlist01 = lst\n",
    "        list_gate_01[index] = cleanlist01\n",
    "    return list_gate_01"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "id": "aab00327-40cc-42cf-adca-787414925a58",
   "metadata": {},
   "outputs": [],
   "source": [
    "def avg_pedestrian_RG(list_gate_01,geomdata):\n",
    "    #This function calculates the average green and red for pedestrians\n",
    "    #The inputs are list_gate_01 which gathers the information of the cycles and geomdata\n",
    "    #The output is geomdata with two new columns : avg_ped_G and avg_ped_R\n",
    "    #if a polygon is not related to any traffic light, we put a 0 in the line of the column.\n",
    "    list_avg_ped_green = []\n",
    "    list_avg_ped_red = []\n",
    "    for lst in list_gate_01 :\n",
    "        if lst == ['0'] :\n",
    "            list_avg_ped_green.append(0)\n",
    "            list_avg_ped_red.append(0)\n",
    "        else :\n",
    "            listlengreen = len_colour(lst,0)\n",
    "            listlenred = len_colour(lst,1)\n",
    "            avglengreen = sum(listlengreen) / len(listlengreen)\n",
    "            avglenred = sum(listlenred) / len(listlenred)\n",
    "            list_avg_ped_green.append(avglengreen/30)\n",
    "            list_avg_ped_red.append(avglenred/30)\n",
    "    geomdata['avg_ped_G'] = list_avg_ped_green\n",
    "    geomdata['avg_ped_R'] = list_avg_ped_red\n",
    "    return geomdata"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "id": "341586b4-cf87-4350-ad80-5a868874ae9c",
   "metadata": {},
   "outputs": [],
   "source": [
    "def conversion_01_in_GR(list_gate_01,geomdata):\n",
    "    #This function converts lists of 0 and 1 into lists of R and G to have a better vision of the cycle when we are looking at the list\n",
    "    #We will had these information on geomdata that is why we need it in the intput and the output\n",
    "    #list_gate_01 have the information about the cycles, we need it in the input.\n",
    "    #geomdata has tw new columns : light which is the list of pedestrian traffic light [R,R,R,R,R,G,G,G,G.....] and index variation, the list of index of each variation of colour\n",
    "    \n",
    "    list_gate_GR = []\n",
    "    listgateGR = []\n",
    "    for lst in list_gate_01 :\n",
    "        if lst == ['0'] :\n",
    "            listgateGR = 0\n",
    "        else :\n",
    "            listgateGR = ['R' if i == 1 else 'G' for i in lst]\n",
    "            #Here R is 1 and G is 0 because we are dealing with pedestrian traffic light it is the opposite of the car traffic light\n",
    "            listgateGR += 20*listgateGR[-1]\n",
    "            #We add 20 frames a the end to be sure that the list is long enought and to no have any error (2 or 3 frames should be enought but we are sure to have no errors with 20)\n",
    "        list_gate_GR.append(listgateGR)\n",
    "    list_i_phaselight = []\n",
    "    index_variation = []\n",
    "\n",
    "    for lst in list_gate_GR :\n",
    "        if lst != 0 :\n",
    "            for j in range(len(lst)-1):\n",
    "                if lst[j] != lst[j+1] :\n",
    "                    index_variation.append(j+1)\n",
    "        list_i_phaselight.append(index_variation)\n",
    "        index_variation = []\n",
    "\n",
    "    geomdata['light'] = list_gate_GR\n",
    "    geomdata['index variation'] = list_i_phaselight\n",
    "    return geomdata"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "id": "5319717e-0a51-4ebd-aea9-c6a0dc5ad93d",
   "metadata": {},
   "outputs": [],
   "source": [
    "def determination_of_phase(gdf2,geomdata):\n",
    "    #determination_of_phase check thanks of the Time information in gdf2 (information of each position) and the phase in geomdata (list of R and G) the exact phase of the polygon the pedestrian is in.\n",
    "    #There are two inputs gdf2 and geomdata\n",
    "    #The ouput is gdf2 with two new columns : phase, the current phase of the pedestrian traffic light (R,G or 0 is there is no traffic light) and %_phase, the percentage of the current phase the pedestrian is in\n",
    "    #gdf2 gets also information in temporally and spatially columns. We have now phase information so we can know about the temporal information.\n",
    "    list_phase = []\n",
    "    list_percent_phase = []\n",
    "\n",
    "    for i in range(len(gdf2)) :\n",
    "        loc_point = gdf2.iloc[i]['loc']\n",
    "        if loc_point != 'footpath':\n",
    "            light_value = geomdata.loc[geomdata['name'] == loc_point, 'light'].values[0]\n",
    "            if light_value == 0 :\n",
    "                phase = 0\n",
    "                percentage = 0\n",
    "            else :\n",
    "                #we are in an area which has a traffic light\n",
    "                time_point = float(gdf2.iloc[i]['Time'])\n",
    "                index_to_check = int(time_point/0.0333)\n",
    "                index_variation = geomdata.loc[geomdata['name'] == loc_point, 'index variation'].values[0]\n",
    "                traffic_light = geomdata.loc[geomdata['name'] == loc_point, 'light'].values[0]\n",
    "                phase = traffic_light[min(index_to_check,len(traffic_light)-1)]\n",
    "            \n",
    "                if index_to_check < index_variation[0]:\n",
    "                    percentage = index_to_check / index_variation[0] * 100\n",
    "                else:\n",
    "                    for j in range(len(index_variation) - 1):\n",
    "                        if index_to_check > index_variation[j] and index_to_check < index_variation[j + 1]:\n",
    "                            percentage = ((index_to_check - index_variation[j]) / (index_variation[j + 1] - index_variation[j])) * 100\n",
    "                            break\n",
    "            \n",
    "        else :\n",
    "            phase = 0\n",
    "            percentage = 0\n",
    "        \n",
    "        list_phase.append(phase)\n",
    "        list_percent_phase.append(percentage)\n",
    "    gdf2['%_phase'] = list_percent_phase\n",
    "    gdf2['phase'] = list_phase\n",
    "                                       \n",
    "    gdf2.loc[gdf2['phase'] == 'R','temporally'] = 1\n",
    "    gdf2.loc[gdf2['loc_type'] == 'road','spatially'] = 1\n",
    "    return gdf2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "id": "56273904-26d3-4178-883d-933a13798513",
   "metadata": {},
   "outputs": [],
   "source": [
    "def percentage_of_violation(gdf2,gdf_trajectory):\n",
    "    #This function calculates the percentage of violation on the whole trajectory, if is superior than 20% we claim that the trajectory can be really studied as a violation\n",
    "    #The inputs are gdf2 (information on each position) and gdf_trajectory (information on each trajectory)\n",
    "    #The ouput is gdf_trajectory with four new colums the % of violation temporally and spatially and the Unintended temp/spat behaviour : the trajectory is composed of a big violation\n",
    "    grouped = gdf2.groupby('TrackID')\n",
    "    gdf_trajectory['percentage_spatially'] = 0\n",
    "    gdf_trajectory['percentage_temporally'] = 0\n",
    "\n",
    "    for track_id, group in grouped:\n",
    "        len_group = len(group)\n",
    "        sum_spatially = group['spatially'].sum()\n",
    "        sum_temporally = group['temporally'].sum()\n",
    "    \n",
    "        percent_spatially = sum_spatially / len_group * 100\n",
    "        #we have the percentage of point on the road\n",
    "        percent_temporally = sum_temporally / len_group *100\n",
    "    \n",
    "        gdf_trajectory.loc[gdf_trajectory['TrackID'] == track_id, 'percentage_spatially'] = percent_spatially\n",
    "        gdf_trajectory.loc[gdf_trajectory['TrackID'] == track_id, 'percentage_temporally'] = percent_temporally\n",
    "                                       \n",
    "    gdf_trajectory['Unintended spat behaviour'] = 0\n",
    "    gdf_trajectory['Unintended temp behaviour'] = 0\n",
    "\n",
    "    for index, row in gdf_trajectory.iterrows():\n",
    "        if row['percentage_spatially'] > 20:\n",
    "            # Let's set the threshold to 20% for the moment\n",
    "            gdf_trajectory.at[index, 'Unintended spat behaviour'] = 1\n",
    "    \n",
    "        if row['percentage_temporally'] > 20:\n",
    "            # Let's set the threshold to 20% for the moment\n",
    "            gdf_trajectory.at[index, 'Unintended temp behaviour'] = 1\n",
    "    return gdf_trajectory"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "id": "131c9561-569c-4322-ab69-6b2fc7f2bc8c",
   "metadata": {},
   "outputs": [],
   "source": [
    "def categories(gdf2) :\n",
    "    #This function creates categories depending on several condition : 1=footpath, 2=crosswalk+Green phase, 3=crosswalk +Red phase, 4=road, 5=crosswalk without traffic light (zebra)\n",
    "    #This function is not really usefull here, it will be for the analysis of results\n",
    "    #The input and ouput are gdf2. We had a columns 'category' on the gdf2 with the information inside.\n",
    "    gdf2['category'] = 0\n",
    "\n",
    "    gdf2['category'] = np.where(gdf2['loc'] == 'footpath', 1, gdf2['category'])\n",
    "    gdf2['category'] = np.where((gdf2['loc_type'] == 'cw') & (gdf2['phase'] == 'G'), 2, gdf2['category'])\n",
    "    gdf2['category'] = np.where((gdf2['loc_type'] == 'cw') & (gdf2['phase'] == 'R'), 3, gdf2['category'])\n",
    "    gdf2['category'] = np.where(gdf2['loc_type'] == 'road', 4, gdf2['category'])\n",
    "    gdf2['category'] = np.where((gdf2['loc_type'] == 'cw') & (gdf2['phase'] == 0), 5, gdf2['category'])\n",
    "    gdf2['Speed'] = gdf2['Speed'].astype(float)\n",
    "    return gdf2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "id": "ee53e36c-2b99-4aac-957b-4ee2a74dd218",
   "metadata": {},
   "outputs": [],
   "source": [
    "def speed_data_polygons(geomdata,gdf2):\n",
    "    #This function is giving information of speed. Each polygon of geomdata received two nex information the average speed and the stp speed.\n",
    "    #These results are put in two new columns of geomdata, which is the ouput\n",
    "    #The inputs are geomdata (we need the list of polygons) and gdf2 (we need the information of speed)\n",
    "    list_of_polygon = pd.unique(geomdata['name'])\n",
    "    avgspeed_polygon = [0] * len(list_of_polygon)\n",
    "    stdspeed_polygon = [0] * len(list_of_polygon)\n",
    "    grouped = gdf2.groupby('loc')\n",
    "    \n",
    "    for i in range(len(list_of_polygon)) :\n",
    "    \n",
    "        new_df = gdf2.loc[gdf2['loc'] == list_of_polygon[i]]\n",
    "        new_df['Speed'] = pd.to_numeric(new_df['Speed'], errors='coerce')\n",
    "    \n",
    "        avg_speed = new_df['Speed'].sum() / len(new_df)\n",
    "        std_speed = new_df['Speed'].std()\n",
    "        avgspeed_polygon[i] = avg_speed\n",
    "        stdspeed_polygon[i] = std_speed\n",
    "\n",
    "    geomdata['avg_speed'] = avgspeed_polygon\n",
    "    geomdata['std_speed'] = stdspeed_polygon\n",
    "    return geomdata"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "id": "64f6569d-23f7-4a92-aa44-894dace475fa",
   "metadata": {},
   "outputs": [],
   "source": [
    "def delete_successive_loc(list_loc):\n",
    "    #This function is designed for the next cell, it will delete successive element. Thanks to it we can know what is the path of a pedestrian in the intersection\n",
    "    arr = np.array(list_loc)  # list_loc is converted in numpy\n",
    "    mask = arr[1:] != arr[:-1]  # mask with the position of loc different from the former one\n",
    "    new_list = np.concatenate(([arr[0]], arr[1:][mask]))  # get a new list from the mask\n",
    "    \n",
    "    return new_list.tolist() "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "id": "ff18040d-496e-4b56-a834-daf585c6e24c",
   "metadata": {},
   "outputs": [],
   "source": [
    "def successive_location_per_traj(gdf_trajectory,gdf2):\n",
    "    #This function give the path of the pedestrian : if we look every successive position of a pedestrian we will have the same information any time because he is moobing frame by frame.\n",
    "    #This is why we delete the successive location to have something like [footpath, crosswalk 2, footpath]\n",
    "    #This path is added in gdf_trajectory the output in a new colum 'list_loc'\n",
    "    #The inputs are gdf_trajectory and gdf2 (has the location of every pedestrian for every frame)\n",
    "    gdf_trajectory['list_loc'] = 0\n",
    "    grouped = gdf2.groupby('TrackID')\n",
    "    list_loc_gdf = []\n",
    "\n",
    "    for track_id, group in grouped:\n",
    "        list_loc = delete_successive_loc(group['loc'].tolist())\n",
    "        list_loc_gdf.append(list_loc)\n",
    "    \n",
    "    gdf_trajectory['list_loc'] = list_loc_gdf\n",
    "    return gdf_trajectory"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "id": "211f70a1-5240-4eff-8c1f-5daea86a6ae3",
   "metadata": {},
   "outputs": [],
   "source": [
    "def violations_per_polygon(gdf2,geomdata):\n",
    "    #This function calculates the total of \"small violation\" per polygon (a \"small violation\" is a violation of a position : a 1 in the column of spatially or temporally in gdf2)\n",
    "    #The inputs are gdf2 (to have the small violations) and geomdata (to have the list of polygons)\n",
    "    #geomdata has two new colums : sum_spatially and sum_temporally, the sum of each small violations, geomdata is the output\n",
    "    grouped = gdf2.groupby('loc')\n",
    "    geomdata['sum_spatially'] = 0\n",
    "    geomdata['sum_temporally'] = 0\n",
    "\n",
    "    for loc, group in grouped:\n",
    "        len_group = len(group)\n",
    "        sum_spatially = group['spatially'].sum()\n",
    "        sum_temporally = group['temporally'].sum()\n",
    "    \n",
    "        geomdata.loc[geomdata['name'] == loc, 'sum_spatially'] = sum_spatially\n",
    "        geomdata.loc[geomdata['name'] == loc, 'sum_temporally'] = sum_temporally\n",
    "    \n",
    "    return geomdata"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "id": "0668937d-4c97-4376-900b-b86643d38fab",
   "metadata": {},
   "outputs": [],
   "source": [
    "def total_trajectory_violation(gdf_trajectory,geomdata,gdf2):\n",
    "    #This function gives the number of big violations (a big part of the trajectory is a violation) per polygon\n",
    "    #This information will be in geomdata (list of polygons) in two new columns : total violation spat and total violation temp\n",
    "    #The inputs are gdf_trajectory (has the information of big violation), geomdata (has the information of polygons) and gdf2 (has the information of localisation and trackID)\n",
    "    #for each trajectory, the code checks all violation per localisation in gdf2. The one that has the most violation is defined as the localisation where the biggest violation is. This polygon received then\n",
    "    #the information in geomdata. The problem of this method is that a big violation is related to only one polygons. It can be different from reality but it is a rare case to have somebody who violates\n",
    "    #two polygons in a big way.\n",
    "    #The output is geomdata with the new colums\n",
    "    gdf_trajectory_spat = gdf_trajectory[gdf_trajectory['Unintended spat behaviour'] == 1]\n",
    "    gdf_trajectory_temp = gdf_trajectory[gdf_trajectory['Unintended temp behaviour'] == 1]\n",
    "    geomdata['total violation spat'] = 0\n",
    "    geomdata['total violation temp'] = 0\n",
    "    for i in range(len(gdf_trajectory_spat)) :\n",
    "        list_loc_i = gdf_trajectory_spat.iloc[i]['list_loc']\n",
    "        maximum = 0\n",
    "        loc_max = 0\n",
    "        trackid_i = gdf_trajectory_spat.iloc[i]['TrackID']\n",
    "        for loc in list_loc_i :\n",
    "            positions = gdf2.loc[(gdf2['loc']==loc) & (gdf2['TrackID']==trackid_i)]\n",
    "            spat_problem = positions.loc[positions['spatially']==1]\n",
    "            if len(spat_problem) > maximum :\n",
    "                maximum = len(spat_problem)\n",
    "                loc_max = loc\n",
    "                #loc_max is the loc where the violation happened\n",
    "        line_geomdata = geomdata.loc[geomdata['name'] == loc_max].index[0]\n",
    "        geomdata.at[line_geomdata,'total violation spat'] += 1\n",
    "    \n",
    "    for i in range(len(gdf_trajectory_temp)) :\n",
    "        list_loc_i = gdf_trajectory_temp.iloc[i]['list_loc']\n",
    "        maximum = 0\n",
    "        loc_max = 0\n",
    "        trackid_i = gdf_trajectory_temp.iloc[i]['TrackID']\n",
    "        for loc in list_loc_i :\n",
    "            positions = gdf2.loc[(gdf2['loc']==loc) & (gdf2['TrackID']==trackid_i)]\n",
    "            temp_problem = positions.loc[positions['temporally']==1]\n",
    "            if len(temp_problem) > maximum :\n",
    "                maximum = len(temp_problem)\n",
    "                loc_max = loc\n",
    "                #loc_max is the loc where the violation happened\n",
    "        line_geomdata = geomdata.loc[geomdata['name'] == loc_max].index[0]\n",
    "        geomdata.at[line_geomdata,'total violation temp'] += 1\n",
    "    return geomdata"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "id": "6d7d728d-34a7-4282-af4f-b80c6e0396f7",
   "metadata": {},
   "outputs": [],
   "source": [
    "#2\n",
    "trajectorycsv = r'C:\\Users\\alexf\\Dropbox\\RSIF Project\\Results\\2-Broadway-ChippendaleAve\\Videos and DFS files\\Trajectories/Broadway&ChippendaleAve_Trajectories.csv'\n",
    "intersectionshapefile = r'C:\\Users\\alexf\\OneDrive\\Bureau\\stage MSP\\video\\inter 2 dfs/inter2shapefileB.shp'\n",
    "gateeventcsv = r'C:\\Users\\alexf\\Dropbox\\RSIF Project\\Results\\2-Broadway-ChippendaleAve\\Videos and DFS files\\CrossEvents/Broadway&ChippendaleAve_GatesEvent.csv'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "id": "58e8443b-5534-40db-8c74-14d5859aa614",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\alexf\\anaconda3\\lib\\site-packages\\geopandas\\geodataframe.py:1443: SettingWithCopyWarning: \n",
      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
      "Try using .loc[row_indexer,col_indexer] = value instead\n",
      "\n",
      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
      "  super().__setitem__(key, value)\n"
     ]
    }
   ],
   "source": [
    "output_df, len_video = extraction_of_data(trajectorycsv)\n",
    "gdf2 = creation_of_gdf2(output_df)\n",
    "gdf_trajectory = creation_of_gdf_trajectory(gdf2)\n",
    "geomdata = gpd.read_file(intersectionshapefile)\n",
    "gdf2 = check_location(gdf2,geomdata)\n",
    "geomdata, list_list_gate = light_gate_column(geomdata)\n",
    "gate_df, list_list_gate = importation_gate_event(gateeventcsv)\n",
    "list_gate_01 = list_01_gates(list_list_gate,gate_df,len_video)\n",
    "list_gate_01 = smooth_data_1(list_gate_01)\n",
    "list_gate_01 = smooth_data_2(list_gate_01)\n",
    "geomdata = avg_pedestrian_RG(list_gate_01,geomdata)\n",
    "geomdata = conversion_01_in_GR(list_gate_01,geomdata)\n",
    "gdf2 = determination_of_phase(gdf2,geomdata)\n",
    "gdf_trajectory = percentage_of_violation(gdf2,gdf_trajectory)\n",
    "gdf2 = categories(gdf2)\n",
    "geomdata = speed_data_polygons(geomdata,gdf2)\n",
    "gdf_trajectory = successive_location_per_traj(gdf_trajectory,gdf2)\n",
    "geomdata = violations_per_polygon(gdf2,geomdata)\n",
    "geomdata = total_trajectory_violation(gdf_trajectory,geomdata,gdf2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "44015045-f94c-4d5c-a419-82d599644156",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "07029505-b12f-4ff5-89e1-5b9210f5326e",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fec8f24c-99c4-4950-9747-c03fa723c711",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f48e4284-3472-4b96-b1cd-0d14f0ba7f5a",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "799c39db-29ab-4556-bf91-a9287db5f049",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
